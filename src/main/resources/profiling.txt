Профилирование осуществлял с помощью утилиты jmap и jconsole.
Данный процесс показал, что по умолчанию JVM использует G1 GC, что меня удивило,
так как на моем ПК всего 2 ядра и 4 Гб оперативной памяти свободной из которой чуть более 1 Гб.
Почему JVM выбрала такой сборщик интересно и непонятно. Предполагаю, что из-за того, что приложение
взаимодействует с базой данных. Возможно этот момент является ключевым.
В ручную менял использование JVM различных сборщиков. Тестирование в течении продолжительного
времени показало, что при использовании G1 GC область Old Generation занята немногим более чем при
использовании других сборщиков. Ситуация по-моему объясняется тем, что в процессе своей работы,
сборщик G1 GC чистит облать Old Generation отдельно от области Young Generation. В связи с этим,
объекты в области Old сохраняются некоторое время дольше при отсутствии на них ссылок у объектов из
области Young. Один непонятный момент, то что, G1 как мне казалось должен вызываться чаще и
общее время простоя приложения должно быть меньше всех остальных сборщиков. Но на продолжительном
временном интервале Serial показал меньшую общую задержку приложения чем G1, а также Serial
запускался большее количество раз. Parallel запускался больше чем Serial и G1. Работа данного
сборщика вообще показала различные результаты по сравнению с другими сборщиками. В большестве
случаев общее время задержки приложения этим сборщиком было больше чем у двух предыдущих. Хотя из
статей я прочитал, что элементы параллелизма заложенные в него должны как раз уменьшить время
простоя приложения. Но случай когда он показал время меньше чем у Serial был всего один.
В остальных случаях он показал время задержки большее чем у Serial и G1. Почему так, я не могу
объяснить. По итогу, вспоминая свой ответ к предыдущему заданию, где я склонялся при большой
нагрузке приложения Tracker использовать Parallel GC. Теперь использовать его бы точно не стал.
Выбор бы сделал в пользу Serial. А при большой нагрузке на приложение при одновременной работе с
базой данных выбрал бы G1 GC. По причине, что раз его внедрили в JVM значит на больших серверных
приложениях он имеет преимущество. На приложение же Tracker я какого-либо его преимущества не
заметил.
Добился состояния выхода виртуальной машины за пределы памяти с помощью ограничения максимального
размера выделяемой памяти и циклического заполнения статического списка.
В процессе работы приложения, наблюдение показало постоянное заполнение области Old Generation.
Что вполне логично, т.к. объекты создаются, а ссылки на них не удаляются.
При переполнении памяти приложение выбросило исключение об ошибке о нехватке памяти и завершилось.
Тестирование каждым сборщиком проводил в течении часа.
G1 показал заполнение области Old на 10%, Serial - 9%, Parallel - 9.4%.
Количество вызовов сборщика: G1 - 7 раз, Serial - 10 раз, Parallel - 11 раз.
Общее время простоя приложения: G1 - 0,057 сек., Serial - 0,048 сек,
Parallel - в одном случае 0,079 сек, в другом 0,046 сек.